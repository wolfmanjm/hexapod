require 'rake'
require 'pathname'
require 'fileutils'

verbose(ENV['verbose'] == '1')

PROG = 'hexapod'

DEBUG = ENV['debug'] == '1'

$using_cpp= false

def pop_path(path)
  Pathname(path).each_filename.to_a[1..-1]
end

def obj2src(fn, e)
  File.absolute_path(File.join(pop_path(File.dirname(fn)), File.basename(fn).ext(e)))
end

# Makefile .d file loader to be used with the import file loader.
# this emulates the -include $(DEPFILES) in a Makefile for the generated .d files
class DfileLoader
  include Rake::DSL

  SPACE_MARK = "\0"

  # Load the makefile dependencies in +fn+.
  def load(fn)
    return if ! File.exists?(fn)
    lines = File.read fn
    lines.gsub!(/\\ /, SPACE_MARK)
    lines.gsub!(/#[^\n]*\n/m, "")
    lines.gsub!(/\\\n/, ' ')
    lines.each_line do |line|
      process_line(line)
    end
  end

  private

  # Process one logical line of makefile data.
  def process_line(line)
    file_tasks, args = line.split(':', 2)
    return if args.nil?
    dependents = args.split.map { |d| respace(d) }
    file_tasks.scan(/\S+/) do |file_task|
      file_task = respace(file_task)
      file file_task => dependents
    end
  end

  def respace(str)
    str.tr SPACE_MARK, ' '
  end
end

# Install the handler
Rake.application.add_loader('d', DfileLoader.new)

ROOTDIR ="/datadisk/aux/Stuff/edison/poky-edison/1.6.1"
TOOLSDIR = "#{ROOTDIR}/sysroots/i686-pokysdk-linux/usr/bin/i586-poky-linux"
TOOLSBIN = "#{TOOLSDIR}/i586-poky-linux-"
CC = "#{TOOLSBIN}gcc"
CCPP = "#{TOOLSBIN}g++"
LD = "#{TOOLSBIN}gcc"
LDCPP = "#{TOOLSBIN}g++"
OBJCOPY = "#{TOOLSBIN}objcopy"
OBJDUMP = "#{TOOLSBIN}objdump"
SIZE = "#{TOOLSBIN}size"
AR = "#{TOOLSBIN}ar"

ARFLAGS = 'cr'

# include a defaults file if present
load 'rakefile.defaults' if File.exists?('rakefile.defaults')

excludes = ['test']
SRC = FileList['./src/**/*.{c,cpp,s}']
SRC.exclude(/#{excludes.join('|')}/) unless excludes.empty?

$using_cpp= SRC.find { |i| File.extname(i) == ".cpp" }.nil? ? false : true

OBJDIR = "BUILD"
OBJ = SRC.collect { |fn| File.join(OBJDIR, pop_path(File.dirname(fn)), File.basename(fn).ext('o')) }

# list of header dependency files generated by compiler
DEPFILES = OBJ.collect { |fn| File.join(File.dirname(fn), File.basename(fn).ext('d')) }

# create destination directories
SRC.each do |s|
  d= File.join(OBJDIR, pop_path(File.dirname(s)))
  FileUtils.mkdir_p(d) unless Dir.exists?(d)
end

INCROOT= '/home/morris/Stuff/edison/poky-edison'
include_dirs = ["#{INCROOT}/opt/include/upm", "#{INCROOT}/opt/include", "./include"]

INCLUDE = (include_dirs).collect { |d| "-I#{d}" }.join(" ")

libs = ['upm-adafruitss', 'mosquitto']
LIBS = libs.flatten.collect{ |l| "-l#{l}" }.join(' ')

defines= []
DEFINES= defines.join(' ')

# Compiler flags used to enable creation of header dependencies.

DEPFLAGS = '-MMD '
CSTD = '-std=c99'
CFLAGS = DEPFLAGS +
    " -m32 -march=core2 -mtune=core2 -msse3 -mfpmath=sse -mstackrealign -fno-omit-frame-pointer " +
    " --sysroot=#{ROOTDIR}/sysroots/core2-32-poky-linux " +
    " -pipe -g -feliminate-unused-debug-types " + (DEBUG ? "-O0 " : "-O2 ")
CPPFLAGS = CFLAGS + ' -std=gnu++11 '

LOPTIONS = []

LDFLAGS = " #{CFLAGS} -L#{INCROOT}/opt/lib -Wl,-O1 -Wl,--hash-style=gnu -Wl,--as-needed "

desc "Run"
task :run do
  sh "#{OBJDIR}/#{PROG}"
end

desc "Upload"
task :upload do
  sh "scp #{OBJDIR}/#{PROG} edison:"
end

# generate the header dependencies if they exist
import(*DEPFILES)

task :clean do
  FileUtils.rm_rf(OBJDIR)
end

task :default => [:build]

task :build => ["#{PROG}"]

task :size do
  sh "#{SIZE} #{OBJDIR}/#{PROG}.elf"
end

task :disasm do
  sh "#{OBJDUMP} -d -f -M reg-names-std --demangle #{OBJDIR}/#{PROG}.elf > #{OBJDIR}/#{PROG}.disasm"
end

task :makelibs do
  sh "#{AR} #{ARFLAGS} hal.a #{LIB_OBJS}"
end

file "#{PROG}" => OBJ do |t|
  puts "Linking"
  sh "#{$using_cpp ? LDCPP : LD} #{LDFLAGS} #{OBJ} #{LIBS} -o #{OBJDIR}/#{t.name}"
end

rule '.o' => lambda{ |objfile| obj2src(objfile, 'cpp') } do |t|
  puts "Compiling #{t.source}"
  sh "#{CCPP} #{CPPFLAGS} #{INCLUDE} #{DEFINES} -c -o #{t.name} #{t.source}"
end

rule '.o' => lambda{ |objfile| obj2src(objfile, 'c') } do |t|
  puts "Compiling #{t.source}"
  sh "#{CC} #{CFLAGS} #{CSTD} #{INCLUDE} #{DEFINES} -c -o #{t.name} #{t.source}"
end

# rule '.o' => lambda{ |objfile| obj2src(objfile, 's') } do |t|
#   puts "Assembling #{t.source}"
#   sh "#{CC} -c -mthumb -mcpu=cortex-m4 -mthumb-interwork -mlittle-endian -mfloat-abi=softfp -mfpu=fpv4-sp-d16 -g -Wa,--no-warn -x assembler-with-cpp #{INCLUDE} -o #{t.name} #{t.source}"
# end
